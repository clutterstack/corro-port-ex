defmodule CorroPort.NodeConfig do
  @moduledoc """
  Manages node-specific configuration for both Elixir and Corrosion.

  In the new architecture, Corrosion config files are generated by startup scripts
  rather than dynamically by the Elixir application. This module now focuses on
  reading the application configuration and providing helper functions.

  Supports both development (multi-node local testing) and production (fly.io) environments.
  """

  @doc """
  Gets the current node configuration from application config.
  """
  def app_node_config do
    Application.get_env(:corro_port, :node_config)
  end

  @doc """
  Gets the current environment (:dev or :prod).
  """
  def get_environment do
    Keyword.fetch!(app_node_config(), :environment) || :dev
  end

  @doc """
  Checks if we're running in production (fly.io).
  """
  def production? do
    get_environment() == :prod
  end

  @doc """
  Gets the path to this node's Corrosion config file.
  """
  def get_config_path do
    Keyword.fetch!(app_node_config(), :corro_config_path)
  end

  @doc """
  Gets the path to this node's Corrosion binary.
  """
  def get_corro_binary_path do
    Keyword.fetch!(app_node_config(), :corrosion_binary)
  end

  @doc """
  Gets the Corrosion node identifier (used in logs and for debugging).
  In production, uses the region-machine_id format for proper region identification.
  In development, uses the pattern "nodeN" where N is the node_id.
  """
  def get_corrosion_node_id do
    if production?() do
      # In production, use the full node_id which includes region prefix
      Keyword.fetch!(app_node_config(), :node_id) || Keyword.fetch!(app_node_config(), :fly_machine_id) || "unknown"
    else
      # In development, use the configured node_id directly
      Keyword.fetch!(app_node_config(), :node_id) || "unknown"
    end
  end

  @doc """
  Gets the Corrosion API port from the application environment.
  """
  def get_corrosion_api_port do
    Keyword.fetch!(app_node_config(), :corrosion_api_port)
  end

  @doc """
  Gets fly.io specific configuration if available.
  Returns nil if not running on fly.io.
  """
  def get_fly_config do

    if production?() do
      %{
        app_name: Keyword.fetch!(app_node_config(), :fly_app_name),
        private_ip: Keyword.fetch!(app_node_config(), :fly_private_ip),
        machine_id: Keyword.fetch!(app_node_config(), :fly_machine_id)
      }
    else
      nil
    end
  end

  @doc """
  Validates that the expected config file exists.
  Useful for startup health checks.
  """
  def validate_config_file do
    config_path = get_config_path()

    cond do
      is_nil(config_path) ->
        {:error, "Config path not set in application config"}

      not File.exists?(config_path) ->
        {:error, "Config file does not exist: #{config_path}"}

      true ->
        {:ok, config_path}
    end
  end

  @doc """
  Validates that the expected Corrosion binary exists and is executable.
  """
  def validate_binary do
    binary_path = get_corro_binary_path()

    cond do
      is_nil(binary_path) ->
        {:error, "Binary path not set in application config"}

      not File.exists?(binary_path) ->
        {:error, "Corrosion binary does not exist: #{binary_path}"}

      not is_executable?(binary_path) ->
        {:error, "Corrosion binary is not executable: #{binary_path}"}

      true ->
        {:ok, binary_path}
    end
  end

  # Private helper to check if file is executable
  defp is_executable?(path) do
    case File.stat(path) do
      {:ok, %{mode: mode}} ->
        # Check if owner execute bit is set (0o100)
        import Bitwise
        (mode &&& 0o100) != 0

      {:error, _} ->
        false
    end
  end
end
